#!/usr/bin/env python3

import argparse
import atexit
import errno
import functools
import json
import logging
import os
import TADA
import sys

from LDMS_Test import LDMSDCluster, LDMSDContainer, process_args, \
                      add_common_args, \
                      assertion_id_get
from time import sleep
from itertools import combinations
import itertools

if __name__ != "__main__":
    raise RuntimeError("This should not be imported as a module")

class Debug(object):
    pass
D = Debug()

logging.basicConfig(format = "%(asctime)s %(name)s %(levelname)s %(message)s",
                    level = logging.INFO)

log = logging.getLogger(__name__)

exec(open(os.getenv("PYTHONSTARTUP", "/dev/null")).read())

#### argument parsing #### ----------------------------------------------------
ap = argparse.ArgumentParser(description = "Test the ovis_log library")
add_common_args(ap)
args = ap.parse_args()
process_args(args)

#### config variables #### ----------------------------------------------------
USER = args.user
PREFIX = args.prefix
COMMIT_ID = args.commit_id
SRC = args.src
CLUSTERNAME = args.clustername
DB = args.data_root

#### spec #### ----------------------------------------------------------------
spec = {
    "name" : CLUSTERNAME,
    "description" : f"{USER}'s test_ovis_log cluster",
    "type" : "FVT",
    "nodes" : [
        {
            "hostname" : "node-1",
            "daemons" : [
                {
                    "name" : "sshd", # for debugging
                    "type" : "sshd",
                }
            ]
        }
    ],
    "cap_add" : [ "SYS_PTRACE" ],
    "image": args.image,
    "ovis_prefix" : PREFIX,
    "env" : {
        "LD_LIBRARY_PATH" : f"/data/tada/lib:{PREFIX}/lib:{PREFIX}/lib64",
    },
    "mounts" : [
            f"{os.path.realpath(sys.path[0])}:/tada-src:ro",
            f"{DB}:/data:rw",
    ] + args.mount +
    ( ["{0}:{0}:ro".format(SRC)] if SRC else [] ),
}

cluster = None

def cleanup():
    cont = cluster.get_container("node-1")
    cont.exec_run("rm -fr /data")

@atexit.register
def at_exit():
    rc = test.finish()
    if args.debug < 2 and cluster is not None:
        cleanup()
        cluster.remove()
    os._exit(rc)

OLEVEL_NAMES = [
    "DEBUG",
    "INFO",
    "WARNING",
    "ERROR",
    "CRITICAL",
    "ALWAYS"
]

OVIS_LOG_M_DT = 0
OVIS_LOG_M_TS = 1
OVIS_LOG_M_TS_NONE = 2

OVIS_LDEFAULT = -1
OLEVEL_BITS = dict(zip(OLEVEL_NAMES[:-1], [pow(2, i) for i in range(len(OLEVEL_NAMES[:-1]))]))
OLEVEL_BITS['ALWAYS'] = functools.reduce(lambda x, y: x | y, list(OLEVEL_BITS.values()))

ALL_COMBS = [ x for x in itertools.chain.from_iterable(itertools.combinations(OLEVEL_NAMES[:-1], n) for n in range(1, len(OLEVEL_NAMES[:-1]) + 1))]
COMB_VALUES = dict(zip([",".join(comb) for comb in ALL_COMBS if len(comb) > 1], \
                         [functools.reduce(lambda x, y : x | y, [OLEVEL_BITS.get(l) for l in comb]) \
                                        for comb in ALL_COMBS if len(comb) > 1]))
COMB_VALUES.update(dict(zip([",".join([l,""]) for l in OLEVEL_NAMES[:-1]], [OLEVEL_BITS[l] for l in OLEVEL_NAMES[:-1]])))
BACK_COMP_VALUES = dict()
for l in OLEVEL_NAMES[:-1]:
    BACK_COMP_VALUES[l] = functools.reduce(lambda x, y : x | y, \
                                  [OLEVEL_BITS[k] for k in OLEVEL_NAMES[OLEVEL_NAMES.index(l):-1]])

DEFAULT_MSG = "This is a test."
LOG_MSG = "libovis_log_test."

LOG_PATTERN = ""

def log_path_get(name):
    return f"/var/log/{name}.log"

def parse_result(s):
    s = s.strip()
    return s.split("=")[1]

def parse_log_file(cont, path, msg = None):
    data = cont.read_file(path)
    data = data.split()
    for l in data:
        if msg is not None:
            if msg not in l:
                continue
        else:
            if "result=" not in l:
                continue
            return parse_result(l)
    return None

# -------------------------------

id = assertion_id_get()

INIT_VALID = next(id)
INIT_NULL_NAME = next(id)
INIT_INVALID_LEVEL = next(id)
INIT_INVALID_MODE = next(id)

LOG_TO_STDOUT = next(id) # log to stdout
LOG_TO_FILE = next(id) # log to a file
OPEN_INVALID = next(id)
REOPEN_NEW_PATH = next(id)

LOGLEVEL2STR = dict()
for l in COMB_VALUES.keys():
    LOGLEVEL2STR[l] = next(id)
LOGLEVEL2STR_INVALID = next(id)

STR2LOGLEVEL = dict()
for l in COMB_VALUES.keys():
    STR2LOGLEVEL[l] = next(id)
for l in BACK_COMP_VALUES.keys():
    STR2LOGLEVEL[l] = next(id)
STR2LOGLEVEL_INVALID = next(id)

# Test the log level masks
QUIET_LOG_LEVEL = next(id)
LOG_LEVEL_MASKS = dict()
for l in COMB_VALUES.keys():
    LOG_LEVEL_MASKS[l] = next(id)
for l in BACK_COMP_VALUES.keys():
    LOG_LEVEL_MASKS[l] = next(id)

LOGROTATE = next(id)
CLOSE = next(id)

# subsystem APIs
SUBSYS_REGISTER_VALID = next(id)
SUBSYS_REGISTER_NULL_NAME = next(id)
SUBSYS_REGISTER_NULL_DESC = next(id)
SUBSYS_REGISTER_EXIST = next(id)
SUBSYS_LOG = next(id)

SET_LOG_LEVEL_BY_NAME = dict()
for l in COMB_VALUES.keys():
    SET_LOG_LEVEL_BY_NAME[l] = next(id)
for l in BACK_COMP_VALUES.keys():
    SET_LOG_LEVEL_BY_NAME[l] = next(id)

SET_LOG_LEVEL_BY_HANDLE = dict()
for l in COMB_VALUES.keys():
    SET_LOG_LEVEL_BY_HANDLE[l] = next(id)
for l in BACK_COMP_VALUES.keys():
    SET_LOG_LEVEL_BY_HANDLE[l] = next(id)

SET_LOG_LEVEL_BY_REGEX_NOT_EXIST = next(id)
SET_LOG_LEVEL_BY_REGEX_INVALID = next(id)
SET_LOG_LEVEL_BY_REGEX = next(id)

LOG_LIST = next(id)

# -------------------------------
#### Test Definition ####
test = TADA.Test(test_suite = "LDMSD",
                 test_type = "FVT",
                 test_name = "libovis_log_test",
                 test_desc = "Test libovis_log",
                 test_user = args.user,
                 commit_id = args.commit_id,
                 tada_addr = args.tada_addr)

test.add_assertion(INIT_VALID,
                   "Call ovis_log_init() with valid arguments")
test.add_assertion(INIT_NULL_NAME,
                   "Call ovis_log_init() with name = NULL")
test.add_assertion(INIT_INVALID_LEVEL,
                   "Call ovis_log_init() with an invalid level")
test.add_assertion(INIT_INVALID_MODE,
                   "Call ovis_log_init() with an invalid mode")

test.add_assertion(OPEN_INVALID,
                   "Open the log file at a non-existing path")
test.add_assertion(LOG_TO_FILE,
                   "Open the log file at a valid path")
test.add_assertion(LOG_TO_STDOUT,
                   "Pass NULL as the path to ovis_log_open")
test.add_assertion(REOPEN_NEW_PATH,
                   "Reopen the log file at another path")

for l in COMB_VALUES.keys():
    test.add_assertion(LOGLEVEL2STR[l],
                   f"Convert '{l}' integer to a string")
test.add_assertion(LOGLEVEL2STR_INVALID,
                   "Convert an invalid integer to a level string")
for l in COMB_VALUES.keys():
    test.add_assertion(STR2LOGLEVEL[l],
                    f"Convert the '{l}' to an integer")
for l in BACK_COMP_VALUES.keys():
    test.add_assertion(STR2LOGLEVEL[l],
                    f"Convert the '{l}' to an integer")
test.add_assertion(STR2LOGLEVEL_INVALID,
                   "Convert an invalid level string to an integer")
test.add_assertion(QUIET_LOG_LEVEL,
                    f"Verify that no messages were printed when the level is QUIET.")
for l in COMB_VALUES.keys():
    test.add_assertion(LOG_LEVEL_MASKS[l],
                    f"Verify that messages of {l} were reported.")
for l in BACK_COMP_VALUES.keys():
    test.add_assertion(LOG_LEVEL_MASKS[l],
                    f"Verify that messages of {l} were reported.")
test.add_assertion(LOG_TO_STDOUT,
                   "Log messages to stdout")
test.add_assertion(LOG_TO_FILE,
                   "Log messages to a file")
test.add_assertion(CLOSE,
                   "Verify that ovis_log_close() works properly")
test.add_assertion(LOGROTATE,
                   "Verify that applications can open, rename, and reopen log files to perform log rotation.")

# subsystems
test.add_assertion(SUBSYS_REGISTER_VALID,
                   "Test a ovis_log_register() call with valid arguments")
test.add_assertion(SUBSYS_REGISTER_NULL_NAME,
                   "Test a ovis_log_register() call with NULL name")
test.add_assertion(SUBSYS_REGISTER_NULL_DESC,
                   "Test a ovis_log_register() call with NULL desc")
test.add_assertion(SUBSYS_REGISTER_EXIST,
                   "Test a ovis_log_register() call with an existing subsystem")

for l in COMB_VALUES.keys():
    test.add_assertion(SET_LOG_LEVEL_BY_NAME[l],
                    f"Verify that messages of {l} were reported from a subsystem.")
for l in BACK_COMP_VALUES.keys():
    test.add_assertion(SET_LOG_LEVEL_BY_NAME[l],
                    f"Verify that messages of {l} were reported from a subsystem.")

for l in COMB_VALUES.keys():
    test.add_assertion(SET_LOG_LEVEL_BY_HANDLE[l],
                    f"Verify that messages of {l} were reported from a subsystem.")
for l in BACK_COMP_VALUES.keys():
    test.add_assertion(SET_LOG_LEVEL_BY_HANDLE[l],
                    f"Verify that messages of {l} were reported from a subsystem.")

test.add_assertion(SET_LOG_LEVEL_BY_REGEX_INVALID,
                "Verify that ovis_log_set_level_by_regex() returns an error " \
                "when the given regular expression string is invalid.")
test.add_assertion(SET_LOG_LEVEL_BY_REGEX_NOT_EXIST,
                "Verify that ovis_log_set_level_by_regex() returns ENOENT " \
                "when the given regular expression string doesn't match any " \
                "logs.")
test.add_assertion(SET_LOG_LEVEL_BY_REGEX,
                "Verify that ovis_log_set_level_by_regex() sets the level " \
                "of the matched log subsystems to the given value.")

test.add_assertion(LOG_LIST, "Verify that ovis_log_list() works correctly.")

# Start the test -----------------
cluster = None
test.start()

log.info("-- Create the cluster -- ")
cluster = LDMSDCluster.get(spec["name"], create = True, spec = spec)

cont = cluster.get_container("node-1")
rc, out = cont.exec_run("make -C /tada-src/C BUILDDIR=/data/tada/lib")
if rc:
    raise RuntimeError("libtada build failed, output: {}".format(out))

log.info("-- Start daemons --")
cluster.start_daemons()
cluster.make_known_hosts()

def write_compile_prog(cont, prog_name, code):
    cont.write_file(f"/data/{prog_name}.c", code)
    rc, out = cont.exec_run(f"gcc -g -O0 -I/opt/ovis/include -o /data/{prog_name} /data/{prog_name}.c " \
                            f"-L/opt/ovis/lib -L/opt/ovis/lib64 -lovis_log -lovis_ev")
    if (rc):
        raise RuntimeError(f"Failed to compile {prog_name}.c. {out}")

def __wait_for_log_worker_code():
    code = f"""\
static void __wait_for_worker(const char *name)
{{
    char worker_name[256];
    sprintf(worker_name, "%s:logger", name);
    ev_worker_t logger = ev_worker_get(worker_name);
    if (logger) {{
        while (ev_pending(logger))
            usleep(100);
    }}
}}
"""
    return code

def __report_str_result_code():
    code = f"""\
#define report_str_result(_s_) printf("result=%s\\n", (_s_))
"""
    return code

def __report_int_result_code():
    code = f"""\
#define report_rc_result(_rc_) printf("result=%d\\n", (_rc_))
"""
    return code

# ovis_log_init

code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

const char *FMT = "n:l:m:";

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc;
    char *name = NULL;
    int level = -1;
    int mode = -1;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'n':
            name = strdup(optarg);
            break;
        case 'l':
            level = atoi(optarg);
            break;
        case 'm':
            mode = atoi(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    rc = ovis_log_init(name, level, mode);
    ovis_log(NULL, OVIS_LALWAYS, "return_code=%d\\n", rc);
    __wait_for_worker(name);
    sleep(1);
    return 0;
}}
"""
write_compile_prog(cont, "ovis_log_init_prog", code)

def ovis_log_init_prog(cont, name = None, level = OLEVEL_BITS["ERROR"], mode = OVIS_LOG_M_DT):
    cmd = "bash -c \"/data/ovis_log_init_prog"
    if name is not None:
        cmd += f" -n {name}"
    if level is not None:
        cmd += f" -l {level}"
    if mode is not None:
        cmd += f" -m {mode}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run ovis_log_init_prog. {out}")
    return rc, out

# INIT_VALID
rc, out = ovis_log_init_prog(cont, name = "libovis_log_test", level = OLEVEL_BITS["ERROR"], mode = OVIS_LOG_M_DT)
test.assert_test(INIT_VALID, "return_code=0" in out and "libovis_log_test" in out, f"'return_code=0' and 'liovis_log_test' in '{out}'")

# INIT_NULL_NAME
rc, out = ovis_log_init_prog(cont, level = OLEVEL_BITS["ERROR"], mode = OVIS_LOG_M_DT)
test.assert_test(INIT_NULL_NAME, "return_code=0" in out and ": :" in out,
                 f"('return_code=0' and ': :') in '{out}'")

# INIT_INVALID_LEVEL
rc, out = ovis_log_init_prog(cont, name = "libovis_log_test", level = -100, mode = OVIS_LOG_M_DT)
test.assert_test(INIT_INVALID_LEVEL, f"return_code={errno.EINVAL}" in out,
                 f"'return_code={errno.EINVAL}' in '{out}'")

# INIT_INVALID_MODE
rc, out = ovis_log_init_prog(cont, name = "libovis_log_test", level = OLEVEL_BITS["ERROR"], mode = -1)
test.assert_test(INIT_INVALID_MODE, f"return_code={errno.EINVAL}" in out,
                 f"'return_code={errno.EINVAL}' in '{out}'")

# ovis_log_open

code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

const char *FMT = "p:n:";

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc;
    char *path;
    char *new;
    path = new = NULL;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'p':
            path = strdup(optarg);
            break;
        case 'n':
            new = strdup(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    rc = ovis_log_init("test", OVIS_LERROR|OVIS_LCRITICAL, 0);
    if (rc)
        exit(rc);

    rc = ovis_log_open(path);
    if (new) {{
        if (rc)
            exit(rc);
        ovis_log(NULL, OVIS_LALWAYS, "first path\\n");
        rc = ovis_log_open(new);
    }}
    ovis_log(NULL, OVIS_LALWAYS, "result=%d\\n", rc);
    __wait_for_worker("test");
    return 0;
}}
"""
write_compile_prog(cont, "ovis_log_open_prog", code)

def ovis_log_open_prog(cont, path = None, new_path = None):
    cmd = "bash -c \"/data/ovis_log_open_prog"
    if path is not None:
        cmd += f" -p {path}"
    if new_path is not None:
        cmd += f" -n {new_path}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run ovis_log_open_prog. {out}")
    return rc, out

# LOG_TO_FILE
cont_path = log_path_get(LOG_TO_FILE)
rc, out = ovis_log_open_prog(cont, path = cont_path)
rc = cont.files_exist(cont_path)
if rc is False:
    test.assert_test(LOG_TO_FILE, rc == True, f"True == is_exist({cont_path})")
else:
    rc = parse_log_file(cont, path = cont_path)
    if rc is None:
        raise RuntimeError("Cannot parse the output")
    test.assert_test(LOG_TO_FILE, int(rc) == 0, f"0 == ovis_log_open({cont_path}) # ({rc})")

# LOG_TO_STDOUT
rc, out = ovis_log_init_prog(cont)
test.assert_test(LOG_TO_STDOUT, f"return_code=0" in out,
                 f"'return_code=0' in '{out}'")

# OPEN_INVALID
rc, out = ovis_log_open_prog(cont, path = f"/data/log/foo/{OPEN_INVALID}.log")
test.assert_test(OPEN_INVALID, "Could not open the log file" in out,
                 f"'Could not open the log file' in '{out}'")

# REOPEN_NEW_PATH
cont_path_1 = f"{log_path_get(REOPEN_NEW_PATH)}.1"
cont_path_2 = f"{log_path_get(REOPEN_NEW_PATH)}.2"
rc, out = ovis_log_open_prog(cont, path = cont_path_1, new_path = cont_path_2)
rc_1 = cont.files_exist(cont_path_1)
rc_2 = cont.files_exist(cont_path_2)
if rc_1 is False:
    test.assert_test(REOPEN_NEW_PATH, rc_1 == True, f"True == is_exist({cont_path_1})")
elif rc_2 is False:
        test.assert_test(REOPEN_NEW_PATH, rc_2 == True, f"True == is_exist({cont_path_2})")
else:
    rc = parse_log_file(cont, path = cont_path_1, msg = "first path")
    rc = parse_log_file(cont, path = cont_path_2)
    if rc is False:
        test.assert_test(REOPEN_NEW_PATH, rc == True, f"'first path' in '{cont_path_1}'")
    elif rc is False:
        test.assert_test(REOPEN_NEW_PATH, rc == True, f"'return_code=0' in {cont_path_2}")
    else:
        test.assert_test(REOPEN_NEW_PATH, True, "ovis_log_open() closes and opens the second path successfully")

# Convert log level mask integer to a string and vice versa
code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

const char *FMT = "m:s:";

{__report_str_result_code()}

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc;
    int masks = -1;
    char *s = NULL;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'm':
            masks = atoi(optarg);
            break;
        case 's':
            s = strdup(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    if (s) {{
        masks = ovis_log_str_to_level(s);
        ovis_log(NULL, OVIS_LALWAYS, "result=%d\\n", masks);
    }} else {{
        s = ovis_log_level_to_str(masks);
        ovis_log(NULL, OVIS_LALWAYS, "result=%s\\n", s);
    }}
    return 0;
}}
"""
prog = "ovis_log_convert_prog"
write_compile_prog(cont, prog, code)

def ovis_log_convert_prog(cont, masks = None, masks_s = None):
    if (masks is None and masks_s is None) or (masks is not None and masks_s is not None):
        raise RuntimeError("Either 'masks' or 'masks_' must be given.")
    cmd = f"bash -c \"/data/{prog}"
    if masks is not None:
        cmd += f" -m {masks}"
    elif masks_s is not None:
        cmd += f" -s {masks_s}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run {prog}. {out}")
    return rc, out

# LOGLEVEL2STR
for l in COMB_VALUES.keys():
    rc, out = ovis_log_convert_prog(cont, masks = COMB_VALUES[l])
    s = parse_result(out)
    test.assert_test(LOGLEVEL2STR[l], s == l, f"{s} == {l} (expected)")

# Convert an invalid enumerate to string
rc, out = ovis_log_convert_prog(cont, masks = 1000000)
s = parse_result(out)
test.assert_test(LOGLEVEL2STR_INVALID, s == "(null)", f"{s} == (null) (expected)")

# STR2LEVEL
for l in COMB_VALUES.keys():
    rc, out = ovis_log_convert_prog(cont, masks_s = f"{l},")
    s = parse_result(out)
    test.assert_test(STR2LOGLEVEL[l], int(s) == COMB_VALUES[l], f"{s} == {COMB_VALUES[l]} (expected)")
for l in BACK_COMP_VALUES.keys():
    rc, out = ovis_log_convert_prog(cont, masks_s = l)
    s = parse_result(out)
    test.assert_test(STR2LOGLEVEL[l], int(s) == BACK_COMP_VALUES[l], f"{s} == {BACK_COMP_VALUES[l]} (expected)")
#
# Convert an invalid loglevel string to a level enumber
rc, out = ovis_log_convert_prog(cont, masks_s = "foo")
s = parse_result(out)
test.assert_test(STR2LOGLEVEL_INVALID, int(s) == -22, f"{s} == -22 (expected)")

# Test the log level threshold
code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

const char *FMT = "m:p:";

{__report_str_result_code()}

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc;
    char *masks_s = NULL;
    char *path = NULL;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'm':
            masks_s = strdup(optarg);
            break;
        case 'p':
            path = strdup(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    int masks = ovis_log_str_to_level(masks_s);
    if (masks < 0)
        exit(-masks);

    rc = ovis_log_init("test", masks, 0);
    if (rc)
        exit(rc);

    rc = ovis_log_open(path);
    if (rc)
        exit(rc);

    ovis_log(NULL, OVIS_LDEBUG, "DEBUG\\n");
    ovis_log(NULL, OVIS_LINFO, "INFO\\n");
    ovis_log(NULL, OVIS_LWARN, "WARNING\\n");
    ovis_log(NULL, OVIS_LERROR, "ERROR\\n");
    ovis_log(NULL, OVIS_LCRITICAL, "CRITICAL\\n");
    ovis_log(NULL, OVIS_LALWAYS, "ALWAYS\\n");

    __wait_for_worker("test");
    return 0;
}}
"""
prog = "ovis_log_prog"
write_compile_prog(cont, prog, code)

def ovis_log_prog(cont, masks, path):
    cmd = f"bash -c \"/data/{prog}"
    cmd += f" -m {masks}"
    cmd += f" -p {path}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run {prog}. {out}")
    return rc, out

# # QUIET
cont_path = log_path_get(QUIET_LOG_LEVEL)
rc, out = ovis_log_prog(cont, masks = "QUIET", path = cont_path)
rc = cont.files_exist(cont_path)
if not rc:
    raise RuntimeError(f"Log file {cont_path} does not exist.")
out = cont.read_file(cont_path)
failed = None
for l in OLEVEL_NAMES:
    if l in out:
        failed = (l not in out, f"'{l}' not in '{out}'")
if failed is not None:
    test.assert_test(QUIET_LOG_LEVEL, failed[0], failed[1])
else:
    test.assert_test(QUIET_LOG_LEVEL, True, "No messages were printed.")
#
# Test log level masks
for c in COMB_VALUES.keys():
    cont_path = log_path_get(LOG_LEVEL_MASKS[c])
    rc, out = ovis_log_prog(cont, masks = c, path = cont_path)
    rc = cont.files_exist(cont_path)
    if not rc:
        raise RuntimeError(f"Log file {cont_path} does not exist.")
    out = cont.read_file(cont_path)
    failed = None
    for l in OLEVEL_NAMES:
        if l == "ALWAYS" or l in c:
            if l not in out:
                failed = (l in out, f"'{l}' in '{out}'")
        else:
            if l in out:
                failed = (l not in out, f"'{l}' not in '{out}'")
    if failed is not None:
        test.assert_test(LOG_LEVEL_MASKS[c], failed[0], failed[1])
    else:
        test.assert_test(LOG_LEVEL_MASKS[c], True, f"Only the messages with the level not less than 'ERROR' were logged.")
for k in BACK_COMP_VALUES.keys():
    cont_path = log_path_get(LOG_LEVEL_MASKS[k])
    rc, out = ovis_log_prog(cont, masks = k, path = cont_path)
    rc = cont.files_exist(cont_path)
    if not rc:
        raise RuntimeError(f"Log file {cont_path} does not exist.")
    out = cont.read_file(cont_path)
    failed = None
    for l in OLEVEL_NAMES:
        if OLEVEL_NAMES.index(l) >= OLEVEL_NAMES.index(k): 
            if l not in out:
                failed = (l in out, f"'{l}' in '{out}'")
        else:
            if l in out:
                failed = (l not in out, f"'{l}' not in '{out}'")
    if failed is not None:
        test.assert_test(LOG_LEVEL_MASKS[k], failed[0], failed[1])
    else:
        test.assert_test(LOG_LEVEL_MASKS[k], True, f"Only the messages with the level not less than 'ERROR' were logged.")
#
# close the log file
code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

const char *FMT = "p:";

{__report_str_result_code()}

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc;
    char *path = NULL;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'p':
            path = strdup(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    rc = ovis_log_init("test", OVIS_LERROR|OVIS_LCRITICAL, 0);
    if (rc)
        exit(rc);

    if (path) {{
        rc = ovis_log_open(path);
        if (rc)
            exit(rc);
    }}

    ovis_log(NULL, OVIS_LALWAYS, "{LOG_MSG}\\n");
    rc = ovis_log_close();

    __wait_for_worker("test");
    if (rc) {{
        ovis_log(NULL, OVIS_LALWAYS, "result=%d\\n", rc);
    }} else {{
        ovis_log(NULL, OVIS_LALWAYS, "std: {LOG_MSG}\\n");
        ovis_log(NULL, OVIS_LALWAYS, "result=%d\/n", rc);
    }}
    __wait_for_worker("test");
    return 0;
}}
"""
prog = "ovis_log_close_prog"
write_compile_prog(cont, prog, code)

def ovis_log_close_prog(cont, path):
    cmd = f"bash -c \"/data/{prog}"
    if path is not None:
        cmd += f" -p {path}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run {prog}. {out}")
    return rc, out

cont_path = log_path_get(CLOSE)
rc, out = ovis_log_close_prog(cont, path = cont_path)
if not cont.files_exist(cont_path):
    test.assert_test(CLOSE, False, f"exist({cont_path})")
else:
    if LOG_MSG not in out:
        test.assert_test(CLOSE, False, f"<msg> in stdout ('{LOG_MSG}' in '{out}') ")
    else:
        out = cont.read_file(cont_path)
        if LOG_MSG not in out:
            test.assert_test(CLOSE, False, f"The log file '{cont_path}' contains '{LOG_MSG}'")
        else:
            test.assert_test(CLOSE, True, "ovis_log_close() works properly.")

# logrotate
code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

const char *FMT = "p:n:m:";

{__report_str_result_code()}

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc;
    char *path = NULL;
    char *new_name = NULL;
    char *msg = NULL;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'p':
            path = strdup(optarg);
            break;
        case 'n':
            new_name = strdup(optarg);
            break;
        case 'm':
            msg = strdup(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    rc = ovis_log_init("test", OVIS_LERROR|OVIS_LCRITICAL, 0);
    if (rc)
        exit(rc);

    rc = ovis_log_open(path);
    if (rc)
        exit(rc);

    __wait_for_worker("test");
    sleep(1);

    ovis_log(NULL, OVIS_LALWAYS, "Before reopen: %s\\n", msg);

    rename(path, new_name);

    rc = ovis_log_open(path);
    if (!rc)
        ovis_log(NULL, OVIS_LALWAYS, "reopen: %s\\n", msg);
    ovis_log(NULL, OVIS_LALWAYS, "result=%d\\n", rc);

    __wait_for_worker("test");

    return 0;
}}
"""
prog = "ovis_log_rotate_prog"
write_compile_prog(cont, prog, code)

def ovis_log_rotate_prog(cont, path = None, new_name = None, msg = LOG_MSG):
    cmd = f"bash -c \"/data/{prog}"
    if path is not None:
        cmd += f" -p {path}"
    if new_name is not None:
        cmd += f" -n {new_name}"
    if msg is not None:
        cmd += f" -m {msg}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run {prog}. {out}")
    return rc, out

cont_path = log_path_get(LOGROTATE)
old_path = f"{cont_path}-old"
rc, std_out = ovis_log_rotate_prog(cont, path = cont_path, new_name = old_path)
if not cont.files_exist(old_path):
    test.assert_test(LOGROTATE, False, f"exist({old_path})")
elif not cont.files_exist(cont_path):
    test.assert_test(LOGROTATE, False, f"exist({cont_path})")
else:
    out = cont.read_file(old_path)
    if LOG_MSG not in out:
        test.assert_test(LOGROTATE, False, f"The old file '{old_path}' contains '{LOG_MSG}'.")
    else:
        out = cont.read_file(cont_path)
        if LOG_MSG not in out:
            test.assert_test(LOGROTATE, False, f"The current file '{cont_path}' contains '{LOG_MSG}'.")
        else:
            test.assert_test(LOGROTATE, True, "ovis_log supports open, rename (external), and reopen.")
#
def __define_subsys_struct():
    code = """\
typedef struct subsys_s {
    int return_code;
    ovis_log_t subsys;
    TAILQ_ENTRY(__subsys) entry;
} *subsys_t;
TAILQ_HEAD(subsys_list, subsys);
"""
    return code

def __report_subsys_code():
    code = """\
void report_subsys_list(struct subsys_list *list)
{
    subsys_t subsys;
    int cnt = 0;

    printf("[");
    TAILQ_FOREACH(subsys, list, entry) {
        if (cnt > 0)
            printf(",");
        printf("{");
        printf("\\"idx\\":%d,", cnt);
        printf("\\"return_code\\":%d", subsys->return_code);
        if (subsys->subsys) {
            printf(",\\"name\\":\\"%s\\",", subsys->subsys->name);
            printf( "\\"desc\\":\\"%s\\",", subsys->subsys->desc);
            printf( "\\"level\\":%d", subsys->subsys->level);
        }
        printf("}");
        cnt++;
    }
    printf("]\\n");
}
"""
    return code
    
# Test ovis_log_register()
def __subsys_register_code(subsys_list_var, subsys_var, name, desc):

    if name is None and desc is None:
        call = "ovis_log_register(NULL, NULL);"
    elif name is None:
        call = f"ovis_log_register(NULL, {desc});"
    elif desc is None:
        call = f"ovis_log_register({name}, NULL);"
    else:
        call = f"ovis_log_register({name}, {desc});"

    code = f"""\
{subsys_var} = malloc(sizeof(*{subsys_var}));
    if (!{subsys_var})
        exit(ENOMEM);
    TAILQ_INSERT_TAIL(&{subsys_list_var}, {subsys_var}, entry);

    errno = 0;
    {subsys_var}->subsys = {call}
    if ({subsys_var}->subsys)
        {subsys_var}->return_code = 0;
    else
        {subsys_var}->return_code = errno;
"""
    return code

# ovis_log_register_prog.c
code = f"""\
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/queue.h>
#include <errno.h>
#include "ovis_log/ovis_log.h"

const char *FMT = "n:d:2";

{__define_subsys_struct()}

{__report_subsys_code()}

struct subsys_list subsys_list;

int main(int argc, char **argv)
{{
    int rc, i;
    int op;
    char *name = NULL;
    char *desc = NULL;
    int is_twice = 0;
    subsys_t subsys;

    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'n':
            name = strdup(optarg);
            break;
        case 'd':
            desc = strdup(optarg);
            break;
        case '2':
            is_twice = 1;
            break;
        default:
            exit(EINVAL);
        }}
    }}

    TAILQ_INIT(&subsys_list);

    rc = ovis_log_init("libovis_log_test", OVIS_LERROR|OVIS_LCRITICAL, 0);
    if (rc)
        exit(rc);

    {__subsys_register_code("subsys_list", "subsys", "name", "desc")}

    if (is_twice) {{
        {__subsys_register_code("subsys_list", "subsys", "name", "desc")}
    }}

    report_subsys_list(&subsys_list);
    return 0;
}}
"""
write_compile_prog(cont, "ovis_log_register_prog", code)

def ovis_log_register_prog(name = None, desc = None, twice = False):
    cmd = "bash -c \"/data/ovis_log_register_prog"
    if name is not None:
        cmd += f" -n {name}"
    if desc is not None:
        cmd += f" -d {desc}"
    if twice:
        cmd += " -2"
    cmd += "\" "
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to test. {out}")
    return rc, json.loads(out.strip())

# SUBSYS_REGISTER_VALID
rc, subsys_list = ovis_log_register_prog("my_subsys", "my_subsys_desc")
exp = [{'idx': 0, 'return_code': 0, 'name' : "my_subsys", \
        "desc" : "my_subsys_desc", \
        'level' : OVIS_LDEFAULT}]
test.assert_test(SUBSYS_REGISTER_VALID, subsys_list == exp,
                f"{subsys_list} == {exp}")

# SUBSYS_REGISTER_NULL_NAME
rc, subsys_list = ovis_log_register_prog(desc = "my_subsys_desc")
exp = [{'idx': 0, 'return_code' : errno.EINVAL}]
test.assert_test(SUBSYS_REGISTER_NULL_NAME, subsys_list == exp,
                 f"{subsys_list} == {exp}")

# SUBSYS_REGISTER_NULL_DESC
rc, subsys_list = ovis_log_register_prog("my_subsys")
exp = [{'idx': 0, 'return_code' : errno.EINVAL}]
test.assert_test(SUBSYS_REGISTER_NULL_DESC, subsys_list == exp,
                 f"{subsys_list} == {exp}")

# SUBSYS_REGISTER_EXIST
rc, subsys_list = ovis_log_register_prog("my_subsys", "my_subsys_desc", twice = True)
exp = [{'idx': 0, 'return_code': 0, 'name' : "my_subsys", \
        "desc" : "my_subsys_desc", \
        'level' : OVIS_LDEFAULT},
        {'idx': 1, 'return_code': errno.EEXIST }]
test.assert_test(SUBSYS_REGISTER_EXIST, subsys_list == exp,
                 f"{subsys_list} == {exp}")


# Test the log level threshold for a subsystem
code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

#define SUBSYS_HANDLE 0
#define SUBSYS_NAME   1

const char *FMT = "m:s:p:t:";

{__report_str_result_code()}

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc;
    char *masks_s = NULL;
    char *subsys_name = NULL;
    ovis_log_t subsys = NULL;
    char *path = NULL;
    int mode = SUBSYS_NAME;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'm':
            masks_s = strdup(optarg);
            break;
        case 's':
            subsys_name = strdup(optarg);
            break;
        case 'p':
            path = strdup(optarg);
            break;
        case 't':
            mode = atoi(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    int masks = ovis_log_str_to_level(masks_s);
    if (masks < 0)
        exit(-masks);

    rc = ovis_log_init("test", OVIS_LQUIET, 0);
    if (rc)
        exit(rc);

    rc = ovis_log_open(path);
    if (rc)
        exit(rc);

    subsys = ovis_log_register(subsys_name, subsys_name);
    if (!subsys)
        exit(ENOMEM);

    if (mode == SUBSYS_NAME)
        rc = ovis_log_set_level_by_name(subsys_name, masks);
    else
        rc = ovis_log_set_level(subsys, masks);
    if (rc)
        exit(rc);

    ovis_log(subsys, OVIS_LDEBUG, "DEBUG\\n");
    ovis_log(subsys, OVIS_LINFO, "INFO\\n");
    ovis_log(subsys, OVIS_LWARN, "WARNING\\n");
    ovis_log(subsys, OVIS_LERROR, "ERROR\\n");
    ovis_log(subsys, OVIS_LCRITICAL, "CRITICAL\\n");
    ovis_log(subsys, OVIS_LALWAYS, "ALWAYS\\n");

    __wait_for_worker("test");

    return 0;
}}
"""
prog = "ovis_log_set_level_prog"
my_subsys = "my_subsys"
write_compile_prog(cont, prog, code)

def ovis_log_set_level_prog(cont, masks, path, type):
    cmd = f"bash -c \"/data/{prog}"
    if masks is not None:
        cmd += f" -m {masks}"
    cmd += f" -s {my_subsys}"
    cmd += f" -p {path}"
    cmd += f" -t {type}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run {prog}. {out}")
    return rc, out

for c in COMB_VALUES.keys():
    cont_path = log_path_get(SET_LOG_LEVEL_BY_NAME[c])
    rc, out = ovis_log_set_level_prog(cont, masks = c, path = cont_path, type = 1)
    rc = cont.files_exist(cont_path)
    if not rc:
        raise RuntimeError(f"Log file {cont_path} does not exist.")
    out = cont.read_file(cont_path)
    failed = None
    for l in OLEVEL_NAMES:
        if l == "ALWAYS" or l in c:
            if l not in out:
                failed = (l in out, f"'{l}' in '{out}'")
        else:
            if l in out:
                failed = (l not in out, f"'{l}' not in '{out}'")
    if failed is not None:
        test.assert_test(SET_LOG_LEVEL_BY_NAME[c], failed[0], failed[1])
    else:
        test.assert_test(SET_LOG_LEVEL_BY_NAME[c], True, \
                         f"Only the messages with the level not less than 'ERROR' were logged.")
for k in BACK_COMP_VALUES.keys():
    cont_path = log_path_get(SET_LOG_LEVEL_BY_NAME[k])
    rc, out = ovis_log_set_level_prog(cont, masks = k, path = cont_path, type = 1)
    rc = cont.files_exist(cont_path)
    if not rc:
        raise RuntimeError(f"Log file {cont_path} does not exist.")
    out = cont.read_file(cont_path)
    failed = None
    for l in OLEVEL_NAMES:
        if OLEVEL_NAMES.index(l) >= OLEVEL_NAMES.index(k): 
            if l not in out:
                failed = (l in out, f"'{l}' in '{out}'")
        else:
            if l in out:
                failed = (l not in out, f"'{l}' not in '{out}'")
    if failed is not None:
        test.assert_test(SET_LOG_LEVEL_BY_NAME[k], failed[0], failed[1])
    else:
        test.assert_test(SET_LOG_LEVEL_BY_NAME[k], True, f"Only the messages with the level not less than 'ERROR' were logged.")

for c in COMB_VALUES.keys():
    cont_path = log_path_get(SET_LOG_LEVEL_BY_HANDLE[c])
    rc, out = ovis_log_set_level_prog(cont, masks = c, path = cont_path, type = 0)
    rc = cont.files_exist(cont_path)
    if not rc:
        raise RuntimeError(f"Log file {cont_path} does not exist.")
    out = cont.read_file(cont_path)
    failed = None
    for l in OLEVEL_NAMES:
        if l == "ALWAYS" or l in c:
            if l not in out:
                failed = (l in out, f"'{l}' in '{out}'")
        else:
            if l in out:
                failed = (l not in out, f"'{l}' not in '{out}'")
    if failed is not None:
        test.assert_test(SET_LOG_LEVEL_BY_HANDLE[c], failed[0], failed[1])
    else:
        test.assert_test(SET_LOG_LEVEL_BY_HANDLE[c], True, \
                         f"Only the messages with the level not less than 'ERROR' were logged.")
for k in BACK_COMP_VALUES.keys():
    cont_path = log_path_get(SET_LOG_LEVEL_BY_HANDLE[k])
    rc, out = ovis_log_set_level_prog(cont, masks = k, path = cont_path, type = 0)
    rc = cont.files_exist(cont_path)
    if not rc:
        raise RuntimeError(f"Log file {cont_path} does not exist.")
    out = cont.read_file(cont_path)
    failed = None
    for l in OLEVEL_NAMES:
        if OLEVEL_NAMES.index(l) >= OLEVEL_NAMES.index(k): 
            if l not in out:
                failed = (l in out, f"'{l}' in '{out}'")
        else:
            if l in out:
                failed = (l not in out, f"'{l}' not in '{out}'")
    if failed is not None:
        test.assert_test(SET_LOG_LEVEL_BY_HANDLE[k], failed[0], failed[1])
    else:
        test.assert_test(SET_LOG_LEVEL_BY_HANDLE[k], True, f"Only the messages with the level not less than 'ERROR' were logged.")

# Test the log level threshold for a subsystem
code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

const char *FMT = "m:r:p:n:";

{__report_str_result_code()}

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc, i;
    char *masks_s = NULL;
    char *regex_s = NULL;
    char *path = NULL;
    const char *subsys_name[10] = {{0}};
    ovis_log_t subsys[10] = {{0}};
    int cnt = 0;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'm':
            masks_s = strdup(optarg);
            break;
        case 'n':
            subsys_name[cnt++] = strdup(optarg);
            break;
        case 'r':
            regex_s = strdup(optarg);
            break;
        case 'p':
            path = strdup(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    int masks = ovis_log_str_to_level(masks_s);
    if (masks < 0)
        exit(-masks);

    rc = ovis_log_init("test", OVIS_LCRITICAL, 0);
    if (rc)
        exit(rc);

    rc = ovis_log_open(path);
    if (rc)
        exit(rc);

    for (i = 0; subsys_name[i]; i++) {{
        subsys[i] = ovis_log_register(subsys_name[i], subsys_name[i]);
        if (!subsys[i])
            exit(ENOMEM);
    }}

    rc = ovis_log_set_level_by_regex(regex_s, masks);
    if (rc) {{
        ovis_log(NULL, OVIS_LALWAYS, "result=%d\\n", rc);
        goto out;
    }}
        

    for (i = 0; subsys_name[i]; i++) {{
        ovis_log(subsys[i], OVIS_LDEBUG, "DEBUG\\n");
        ovis_log(subsys[i], OVIS_LINFO, "INFO\\n");
        ovis_log(subsys[i], OVIS_LWARN, "WARNING\\n");
        ovis_log(subsys[i], OVIS_LERROR, "ERROR\\n");
        ovis_log(subsys[i], OVIS_LCRITICAL, "CRITICAL\\n");
        ovis_log(subsys[i], OVIS_LALWAYS, "ALWAYS\\n");
    }}

out:
    __wait_for_worker("test");
    return 0;
}}
"""
prog = "ovis_log_set_level_regex_prog"
write_compile_prog(cont, prog, code)

def ovis_log_set_level_regex_prog(cont, masks, path, names, regex_s):
    cmd = f"bash -c \"/data/{prog}"
    if masks is not None:
        cmd += f" -m {masks}"
    cmd += f" -p {path}"
    cmd += f" -r {regex_s}"
    for n in names:
        cmd += f" -n {n}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run {prog}. {out}")
    return rc, out

cont_path = log_path_get(SET_LOG_LEVEL_BY_REGEX_INVALID)
rc, out = ovis_log_set_level_regex_prog(cont, masks = "ERROR", path = cont_path,
                                        names = ["xprt"],
                                        regex_s = "*+")
rc = cont.files_exist(cont_path)
if not rc:
    raise RuntimeError(f"Log file {cont_path} does not exist.")
out = cont.read_file(cont_path)
test.assert_test(SET_LOG_LEVEL_BY_REGEX_INVALID, f"result={errno.EINVAL}" in out,
                 f"'result={errno.EINVAL}' in '{out}'")

cont_path = log_path_get(SET_LOG_LEVEL_BY_REGEX_NOT_EXIST)
rc, out = ovis_log_set_level_regex_prog(cont, masks = "ERROR", path = cont_path,
                                        names = ["xprt", "xprt.zap"],
                                        regex_s = "config")
rc = cont.files_exist(cont_path)
if not rc:
    raise RuntimeError(f"Log file {cont_path} does not exist.")
out = cont.read_file(cont_path)
test.assert_test(SET_LOG_LEVEL_BY_REGEX_NOT_EXIST, f"result={errno.ENOENT}",
                f"'result={errno.ENOENT}' in '{out}'")

matched = ["xprt", "xprt.zap", "xprt.ldms"]
not_matched = ["config"]
cont_path = log_path_get(SET_LOG_LEVEL_BY_REGEX)
rc, out = ovis_log_set_level_regex_prog(cont, masks = "ERROR", path = cont_path,
                                        names = matched + not_matched, 
                                        regex_s = "xprt.*")
if (rc):
    raise Exception(f"Failed to run {prog}")
rc = cont.files_exist(cont_path)
if not rc:
    raise RuntimeError(f"Log file {cont_path} does not exist.")
out = cont.read_file(cont_path)
failed = None
for n in matched:
    for l in out.split("\n"):
        if f"{n}:" in l:
            cond = (f"{n}:" in l) and not (("ERROR" in l) and ("ALWAYS" in l))
            if cond:
                failed = (cond, f"('{n}:' in '{l}' and (('ERROR' in '{l}') or ('ALWAYS' in {l}))")
                break
    if failed is not None:
        break
for n in not_matched:
    for l in out.split("\n"):
        if f"{n}:" in l:
            cond = (f"{n}:" in l) and not (("CRITICAL" in l) and ("ALWAYS" in l))
            if cond:
                failed = (cond, f"('{n}:' in '{l}' and (('CRITICAL' in '{l}') or ('ALWAYS' in {l}))")
if failed is not None:
    test.assert_test(SET_LOG_LEVEL_BY_REGEX, failed[0], failed[1])
else:
    test.assert_test(SET_LOG_LEVEL_BY_REGEX, True, "ovis_log_set_level_by_regex() works as expected")

# Test ovis_log_list()
code = f"""\
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include "ovis_ev/ev.h"
#include "ovis_log/ovis_log.h"

const char *FMT = "m:p:n:";

{__report_str_result_code()}

{__wait_for_log_worker_code()}

int main(int argc, char **argv)
{{
    int op, rc, i;
    char *path = NULL;
    char *subsys_name[10] = {{0}};
    int level;
    ovis_log_t subsys[10] = {{0}};
    int cnt = 0;
    char *name;
    char *level_s;
    
    while ((op = getopt(argc, argv, FMT)) != -1) {{
        switch (op) {{
        case 'n':
            subsys_name[cnt++] = strdup(optarg);
            break;
        case 'p':
            path = strdup(optarg);
            break;
        default:
            exit(EINVAL);
        }}
    }}

    rc = ovis_log_init("test", OVIS_LCRITICAL, 0);
    if (rc)
        exit(rc);

    for (i = 0; subsys_name[i]; i++) {{
        name = subsys_name[i];
        level_s = strchr(subsys_name[i], ':');
        level_s[0] = '\\0';
        level_s++;
        subsys[i] = ovis_log_register(subsys_name[i], subsys_name[i]);
        if (!subsys[i])
            exit(ENOMEM);
        if (0 != strcasecmp(level_s, "DEFAULT")) {{
            level = ovis_log_str_to_level(level_s);
            ovis_log_set_level(subsys[i], level);
        }}
    }}

    char *s = ovis_log_list(NULL);
    if (!s) {{
        rc = errno;
        exit(rc);
    }} else {{
        FILE *fout = fopen(path, "w");
        fprintf(fout, "%s\\n", s);
        close(fout);
    }}
    free(s);
out:
    __wait_for_worker("test");
    return 0;
}}
"""
prog = "ovis_log_list_prog"
write_compile_prog(cont, prog, code)

def ovis_log_list_prog(cont, path, names):
    cmd = f"bash -c \"/data/{prog}"
    cmd += f" -p {path}"
    for n in names:
        cmd += f" -n {n}"
    cmd += "\" "
    log.debug(cmd)
    rc, out = cont.exec_run(cmd)
    if (rc):
        raise RuntimeError(f"Failed to run {prog}. {out}")
    return rc, out

cont_path = log_path_get(LOG_LIST)
names = ["config", "xprt", "xprt.ldms", "xprt.zap"]
levels = ["default", "ERROR", "INFO,CRITICAL", "WARNING,"]
info = [f"{n}:{l}" for n, l in zip(names, levels)]
rc, out = ovis_log_list_prog(cont, path = cont_path, names = info)
rc = cont.files_exist(cont_path)
if not rc:
    raise RuntimeError(f"Log file {cont_path} does not exist.")
out = cont.read_file(cont_path)
subsys_info = json.loads(out.strip())
exp = [{"name": "test",
        "desc": "The default log subsystem",
        "level" : "CRITICAL,"}]
for n, l in zip(names, levels):
    exp += [{"name" : n,
            "desc" : n,
            "level" : l if l != "ERROR" else "ERROR,CRITICAL"}]
test.assert_test(LOG_LIST, exp == subsys_info, f"'{exp}' == '{subsys_info}'")
